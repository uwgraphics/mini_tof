/**
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/***********************************/
/*    VL53LMZ ULD CNH Data		   */
/***********************************/
/*
 * This example how to configure, capture and decode CNH data from
 * the VL53L7CH/VL53LCH sensors.
 *
 * In this example, we also suppose that the number of targets per zone is
 * set to 1(see file platform.h).
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <Arduino.h>

#define Binary_mode
// #define Human_readable_mode
// #define debugging_mode

#include "vl53lmz_api.h"
#include "vl53lmz_plugin_cnh.h"
extern void xprintf(const char *format, ...);
extern void vl53lmz_on(VL53LMZ_Configuration *p_dev);
extern void vl53lmz_off(VL53LMZ_Configuration *p_dev);
int the_ranging_part(void);
// #define  Serial Serial

/* techincally invalid conversion in cpp (but fine in C)*/
// typedef union
// {
// 	float floatingPoint;
// 	byte binary[4];
// } binaryFloat;

// typedef union
// {
// 	int32_t signed_int;
// 	byte binary[4];
// } binaryInt;

/*********************************/
/*   VL53LMZ ranging variables  */
/*********************************/

static uint8_t status, loop1, isAlive, isReady, i;
static VL53LMZ_Configuration Dev;	/* Sensor configuration */
static VL53LMZ_ResultsData Results; /* Results data from VL53LMZ */

static VL53LMZ_Motion_Configuration cnh_config; /* Motion Configuration is shared with CNH */

static cnh_data_buffer_t cnh_data_buffer; /* cnh_data_bufer_t is sized to take the largest data transfer  */
/* possible from the device. If smaller CNH configuration is 	*/
/* used then cnh_data_buffer size could be make smaller.		*/

static uint32_t cnh_data_size; /* This will be used to record the actual size of CNH data 		*/
/* generated by the set CNH configuration.						*/

static int agg_id, bin_num;
static float amb_value, bin_value;

/* variables needed for call to vl53lmz_cnh_get_mem_block_addresses() */
static int32_t *p_hist = NULL;
static int8_t *p_hist_scaler = NULL;
static int32_t *p_ambient = NULL;
static int8_t *p_ambient_scaler = NULL;

int example12(VL53LMZ_Configuration *input_Dev)
{
	Dev = *input_Dev;

	p_hist = NULL;
	p_hist_scaler = NULL;
	p_ambient = NULL;
	p_ambient_scaler = NULL;

	/*********************************/
	/*      Customer platform        */
	/*********************************/

	/* Fill the platform structure with customer's implementation. For this
	 * example, only the I2C address is used.
	 */
	Dev.platform.address = VL53LMZ_DEFAULT_I2C_ADDRESS;

	/* (Optional) Reset sensor toggling PINs (see platform, not in API) */
	// Reset_Sensor(&(Dev.platform));
	// Reset the sensor by toggling the LPN pin
	vl53lmz_off(&Dev);
	vl53lmz_on(&Dev);

	// TODO: change for custom address (also code might be wrong copy from og arudino)
	if (Dev.platform.dev_i2c && (VL53LMZ_DEFAULT_I2C_ADDRESS != Dev.platform.address))
	{
		status = vl53lmz_set_i2c_address(&Dev, VL53LMZ_DEFAULT_I2C_ADDRESS);
		if (status != VL53LMZ_STATUS_OK)
		{
			return VL53LMZ_STATUS_ERROR;
		}
	}
	/* (Optional) Set a new I2C address if the wanted address is different
	 * from the default one (filled with 0x20 for this example).
	 */
	// status = vl53lmz_set_i2c_address(&Dev, 0x20);

	/*********************************/
	/*   Power on sensor and init    */
	/*********************************/
	// status = vl53lmz_stop_ranging(&Dev);

	/* (Optional) Check if there is a VL53LMZ sensor connected */
	status = vl53lmz_is_alive(&Dev, &isAlive);
	if (!isAlive || status)
	{
		xprintf("VL53LMZ not detected at requested address: status %i; isAlive: %i\n", status, isAlive);
		return status;
	}

	/* (Mandatory) Initialise the VL53LMZ sensor */
	status = vl53lmz_init(&Dev);
	if (status)
	{
		xprintf("VL53LMZ ULD Loading failed\n");
		return status;
	}

	xprintf("VL53LMZ ULD ready ! (Version : %s)\n",
			VL53LMZ_API_REVISION);

	/*********************************/
	/*  Set basic ranging settings   */
	/*********************************/
	status = vl53lmz_set_resolution(&Dev, 64);
	status |= vl53lmz_set_ranging_mode(&Dev, VL53LMZ_RANGING_MODE_CONTINUOUS);
	status |= vl53lmz_set_ranging_frequency_hz(&Dev, 30);
	status |= vl53lmz_set_integration_time_ms(&Dev, 20);
	if (status)
	{
		xprintf("ERROR - Failed basic configuration sequence, status=%u\n",
				status);
		return status;
	}

	/*********************************/
	/*  CNH specific configuration   */
	/*********************************/

	/* Populate the basic CNH parameters into the CNH configuration structure */
	status = vl53lmz_cnh_init_config(&cnh_config, 0, /* StartBin 	*/
									 12,			 /* NumBins   	*/
									 8);			 /* SubSample 	*/

	if (status != VL53LMZ_STATUS_OK)
	{
		xprintf("ERROR at %s(%d) : vl53lmz_cnh_init_config failed : %d\n",
				__func__, __LINE__, status);
		return status;
	}

	/* Add the aggregate map that maps zones to aggregates. Resolution of map 	*/
	/* must follow that set by vl53lmz_set_resolution(), either 16 or 64 zones.	*/
	status = vl53lmz_cnh_create_agg_map(&cnh_config, 64, /* Resolution. Must match value used in vl53lmz_set_resolution() */
										0,				 /* StartX 		*/
										0,				 /* StartY 		*/
										1,				 /* MergeX		*/
										1,				 /* MergeY		*/
										8,				 /* Cols			*/
										8);				 /* Rows 		*/
	if (status != VL53LMZ_STATUS_OK)
	{
		xprintf("ERROR at %s(%d) : vl53lmz_cnh_create_agg_map failed : %d\n",
				__func__, __LINE__, status);
		return status;
	}

	/* Check that the requested configuration will not generate CNH data that is 		*/
	/* too large for the available space on the sensor.									*/
	/* Store the size of data generate so we can next setup an optimize data transfer 	*/
	/* from sensor to host.																*/
	status = vl53lmz_cnh_calc_required_memory(&cnh_config, &cnh_data_size);
	if (status != VL53LMZ_STATUS_OK)
	{
		xprintf("ERROR at %s(%d) : vl53lmz_cnh_calc_required_memory : %d\n",
				__func__, __LINE__, status);
		if (cnh_data_size < 0)
		{
			xprintf("Required memory is too high : %lu.	Maximum is %lu!\n",
					cnh_data_size, VL53LMZ_CNH_MAX_DATA_BYTES);
		}
		return status;
	}

	/* Send this CNH configuration to the sensor.										*/
	status = vl53lmz_cnh_send_config(&Dev, &cnh_config);
	if (status != VL53LMZ_STATUS_OK)
	{
		xprintf("ERROR at %s(%d) : vl53lmz_cnh_send_config failed : %d\n",
				__func__, __LINE__, status);
		return status;
	}

	/* Because we want to use a non-standard data transfer from the device we can not   	*/
	/* use the standard vl53lmz_start_ranging() function, instead we need to use  			*/
	/* vl53lmz_create_output_config() followed by vl53lmz_send_output_config_and_start() 	*/
	/* This allows us to modify the data transfer requested between the two functions.		*/

	/* First create the standard data upload(output) configuration. 						*/
	status = vl53lmz_create_output_config(&Dev);
	if (status != VL53LMZ_STATUS_OK)
	{
		xprintf("ERROR at %s(%d) : vl53lmz_create_output_config failed : %d\n",
				__func__, __LINE__, status);
		return status;
	}

	/* Next, add the CNH data block, sized correctly for the configuration we are using. */
	union Block_header cnh_data_bh;
	cnh_data_bh.idx = VL53LMZ_CNH_DATA_IDX;
	cnh_data_bh.type = 4;
	cnh_data_bh.size = cnh_data_size / 4;
	status = vl53lmz_add_output_block(&Dev, cnh_data_bh.bytes);
	if (status != VL53LMZ_STATUS_OK)
	{
		xprintf("ERROR at %s(%d) : vl53lmz_add_output_block failed : %d\n",
				__func__, __LINE__, status);
		return status;
	}

	/*********************************/
	/*  Start the sensor ranging     */
	/*********************************/

	/* Finally, send the output configuration and start the sensor ranging. */
	status = the_ranging_part();

	xprintf("End of ULD demo\n");
	return status;
}

int the_ranging_part()
{
	int status;
	status = vl53lmz_send_output_config_and_start(&Dev);
	xprintf("Started ranging\n", status);
	//	char* result = "";
	//	char* temp;
	//	char* temp1;
	//	size_t temp_size = 0;
	size_t scan_count = 0;
	size_t input = 0;
	char the_temp_byte_array[4];
	float temp_agg_id = 0;

	while (1)
	{
		//		scanf("%i\n",&input);
		//		if (input > 0) break;
		uint32_t start1 = micros();
		status = vl53lmz_check_data_ready(&Dev, &isReady);
		if (isReady)
		{
			uint32_t start2 = micros();
			//			 xprintf("\033[2J");
			vl53lmz_get_ranging_data(&Dev, &Results);

			uint32_t start3 = micros();

			/* As the sensor is set in 4x4 mode by default, we have a total of 16 zones */
			/* to print. This example assumes VL53LMZ_NB_TARGET_PER_ZONE == 1 */
			//			 xprintf("Print data no : %i\n", Dev.streamcount);
			// xprintf("Print data no : %i\n", scan_count++);
			// for (i = 0; i < 16; i++)
			// {
			// 	//				temp1 = asn xprintf(temp, &temp_size, "Zone : %3d, Status : %3u, Distance : %4d mm\n", i,
			// 	//												Results.target_status[VL53LMZ_NB_TARGET_PER_ZONE * i],
			// 	//												Results.distance_mm[VL53LMZ_NB_TARGET_PER_ZONE * i]);
			// 	//				free(temp);
			// 	//				temp = temp1;
			// 	//				 xprintf("%s\n", temp);
			// 	xprintf("Zone : %3d, Status : %3u, Distance : %4d mm\n", i,
			// 			Results.target_status[VL53LMZ_NB_TARGET_PER_ZONE * i],
			// 			Results.distance_mm[VL53LMZ_NB_TARGET_PER_ZONE * i]);
			// }

			/* Because we use a non-standard upload configuration for CNH data we   */
			/* must extract the data from the ULD transfer buffer and place it in   */
			/* our own data area before accessing it.								*/
			status = vl53lmz_results_extract_block(&Dev, VL53LMZ_CNH_DATA_IDX,
												   (uint8_t *)cnh_data_buffer, cnh_data_size);
			if (status != VL53LMZ_STATUS_OK)
			{
				xprintf(
					"ERROR at %s(%d) : vl53lmz_results_extract_block failed : %d\n",
					__func__, __LINE__, status);
				return status;
			}

			for (agg_id = 0; agg_id < cnh_config.nb_of_aggregates; agg_id++)
			{
				/* Start address of each aggregates data blocks within the cnh_data_buffer depends	*/
				/* on the exact CNH configuration in use. Function below calculates these start 	*/
				/* locations for us.																*/
				vl53lmz_cnh_get_block_addresses(&cnh_config, agg_id,
												cnh_data_buffer, &(p_hist), &(p_hist_scaler),
												&(p_ambient), &(p_ambient_scaler));

				/* there is just a single ambient value per aggregate */
				// bfloat.floatingPoint = (float)scan_count++;
				// Serial.write(bfloat.binary, 4);
				amb_value = ((float)*p_ambient) / (2 << *p_ambient_scaler);

#ifdef Human_readable_mode
				xprintf("Agg, %2d, Ambient, %.2f, Bins, ", agg_id, amb_value);
#endif

#ifdef Binary_mode
				memcpy(the_temp_byte_array, &temp_agg_id, 4);
				temp_agg_id++;
				Serial.write(the_temp_byte_array, 4);
				// bfloat.floatingPoint = float(agg_id)
				// Serial.write(bfloat.binary, 4);
				memcpy(the_temp_byte_array, &amb_value, 4);
				Serial.write(the_temp_byte_array, 4);
#endif

				for (bin_num = 0; bin_num < cnh_config.feature_length;
					 bin_num++)
				{
					bin_value = ((float)p_hist[bin_num]) / (2 << p_hist_scaler[bin_num]);

#ifdef Binary_mode
					memcpy(the_temp_byte_array, &bin_value, 4);
					Serial.write(the_temp_byte_array, 4);
#endif

#ifdef Human_readable_mode
					xprintf("%.1f, ", bin_value);
#endif
				}

#ifdef Human_readable_mode
				xprintf("\n\r");
#endif

#ifdef Binary_mode
				char binary123[4] = {0xff, 0xff, 0xff, 0xff};
				Serial.write(binary123, 4);
#endif
			}
			uint32_t end = micros();

#if defined(Human_readable_mode) || defined(debugging_mode)
			xprintf("\n\n\n\n\n\n\n\n\n\n\n");
			xprintf("%i %i %i \n\r", start2 - start1, start3 - start2, end - start3);
			xprintf("Print data no : %i\n\r", scan_count++);

			/* if you want to read output enable this*/
			/* don't use if you want to save to files*/
			xprintf("\033[100A"); // Move up 100 lines;
								  //			loop++;
#endif
		}

		/* Wait a few ms to avoid too high polling (function in platform
		 * file, not in API) */

		/*default is 5 ms*/
		// WaitMs(&(Dev.platform), 1);
		temp_agg_id = 0;
	}

	status = vl53lmz_stop_ranging(&Dev);
	xprintf("Stop ranging autonomous\n");

	return status;
}
